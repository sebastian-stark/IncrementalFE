\hypertarget{classincremental_f_e_1_1_f_e_model}{}\section{incremental\+FE\+:\+:F\+E\+Model$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$ Class Template Reference}
\label{classincremental_f_e_1_1_f_e_model}\index{incremental\+F\+E\+::\+F\+E\+Model$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$@{incremental\+F\+E\+::\+F\+E\+Model$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$}}


{\ttfamily \#include $<$fe\+\_\+model.\+h$>$}



Collaboration diagram for incremental\+FE\+:\+:F\+E\+Model$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=242pt]{classincremental_f_e_1_1_f_e_model__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classincremental_f_e_1_1_f_e_model_a230a5830a967893387b9010b9bd9b65b}{F\+E\+Model} (const dealii\+::\+Galerkin\+Tools\+::\+Total\+Potential$<$ spacedim $>$ \&total\+\_\+potential, dealii\+::\+Galerkin\+Tools\+::\+Triangulation\+System$<$ spacedim $>$ \&tria\+\_\+system, const dealii\+::\+Mapping$<$ spacedim, spacedim $>$ \&mapping\+\_\+domain, const dealii\+::\+Mapping$<$ spacedim-\/1, spacedim $>$ \&mapping\+\_\+interface, \hyperlink{classincremental_f_e_1_1_global_data_incremental_f_e}{Global\+Data\+Incremental\+FE}$<$ spacedim $>$ \&\hyperlink{classincremental_f_e_1_1_f_e_model_aa6f80778241b26906af1f571517102dd}{global\+\_\+data}, const \hyperlink{classincremental_f_e_1_1_constraints}{Constraints}$<$ spacedim $>$ \&\hyperlink{classincremental_f_e_1_1_f_e_model_a33a622c3c53ea4bee3bdefac06201c70}{constraints}, const dealii\+::\+Galerkin\+Tools\+::\+Solver\+Wrapper$<$ Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type, dealii\+::\+Galerkin\+Tools\+::\+Two\+Block\+Sparsity\+Pattern $>$ \&\hyperlink{classincremental_f_e_1_1_f_e_model_a609de66ca9623d737bf3a45a37bb7690}{solver\+\_\+wrapper}, const bool \hyperlink{classincremental_f_e_1_1_f_e_model_a65b5910cfba2feb26933ad451ceff628}{make\+\_\+hanging\+\_\+node\+\_\+constraints}=true)
\item 
\hyperlink{classincremental_f_e_1_1_f_e_model_ae4d9513474928ef225245928410f984b}{$\sim$\+F\+E\+Model} ()
\item 
int \hyperlink{classincremental_f_e_1_1_f_e_model_a1528bdeba89d6f4774526a2ed9412047}{do\+\_\+time\+\_\+step} (const double t, const dealii\+::\+Affine\+Constraints$<$ double $>$ \&custom\+\_\+constraints=dealii\+::\+Affine\+Constraints$<$ double $>$(), const dealii\+::\+Affine\+Constraints$<$ double $>$ \&ignore\+\_\+constraints=dealii\+::\+Affine\+Constraints$<$ double $>$())
\item 
std\+::pair$<$ const double, const double $>$ \hyperlink{classincremental_f_e_1_1_f_e_model_af3c39fb15e308e6979b55fc4b988b3a2}{compute\+\_\+distance\+\_\+to\+\_\+other\+\_\+solution} (const \hyperlink{classincremental_f_e_1_1_f_e_model}{F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$ \&other\+\_\+incremental\+\_\+fe, const dealii\+::\+Quadrature$<$ spacedim $>$ quadrature\+\_\+domain, const dealii\+::\+Quadrature$<$ spacedim-\/1 $>$ quadrature\+\_\+interface, const {\bf dealii\+::\+Vector\+Tools\+::\+Norm\+Type} norm\+\_\+type=dealii\+::\+Vector\+Tools\+::\+Norm\+Type\+::\+L2\+\_\+norm, const dealii\+::\+Component\+Mask component\+\_\+mask\+\_\+domain=dealii\+::\+Component\+Mask(), const dealii\+::\+Component\+Mask component\+\_\+mask\+\_\+interface=dealii\+::\+Component\+Mask(), const double exponent=2.) const 
\item 
std\+::pair$<$ const double, const double $>$ \hyperlink{classincremental_f_e_1_1_f_e_model_ae785f6ada313fec0811414e3f4294faf}{compute\+\_\+distance\+\_\+to\+\_\+exact\+\_\+solution} (const dealii\+::\+Function$<$ spacedim $>$ \&exact\+\_\+solution\+\_\+domain, const dealii\+::\+Function$<$ spacedim $>$ \&exact\+\_\+solution\+\_\+interface, const dealii\+::\+Quadrature$<$ spacedim $>$ quadrature\+\_\+domain, const dealii\+::\+Quadrature$<$ spacedim-\/1 $>$ quadrature\+\_\+interface, const {\bf dealii\+::\+Vector\+Tools\+::\+Norm\+Type} norm\+\_\+type=dealii\+::\+Vector\+Tools\+::\+Norm\+Type\+::\+L2\+\_\+norm, const dealii\+::\+Component\+Mask component\+\_\+mask\+\_\+domain=dealii\+::\+Component\+Mask(), const dealii\+::\+Component\+Mask component\+\_\+mask\+\_\+interface=dealii\+::\+Component\+Mask(), const double exponent=2.\+0) const 
\item 
void \hyperlink{classincremental_f_e_1_1_f_e_model_acb0d11f9d7a71971732d041a5cb4376a}{read\+\_\+solution\+\_\+from\+\_\+file} (const std\+::string file\+\_\+name)
\item 
void \hyperlink{classincremental_f_e_1_1_f_e_model_a7dd3d4c235f2fd04a41184892e319601}{write\+\_\+solution\+\_\+to\+\_\+file} (const std\+::string file\+\_\+name) const 
\item 
void \hyperlink{classincremental_f_e_1_1_f_e_model_a2e13285d3ec061e14dacaaf174ee5bf5}{write\+\_\+output\+\_\+independent\+\_\+fields} (const std\+::string file\+\_\+name\+\_\+domain, const std\+::string file\+\_\+name\+\_\+interface, const unsigned int n\+\_\+subdivisions=1)
\item 
const dealii\+::\+Galerkin\+Tools\+::\+Assembly\+Helper$<$ spacedim $>$ \& \hyperlink{classincremental_f_e_1_1_f_e_model_a32bc459c2816503c0b70a4f1a6730917}{get\+\_\+assembly\+\_\+helper} ()
\item 
double \hyperlink{classincremental_f_e_1_1_f_e_model_ab557cb22e2a0bd89cc7f0c2d048524ba}{get\+\_\+potential\+\_\+value} () const 
\item 
void \hyperlink{classincremental_f_e_1_1_f_e_model_af838cd26f882b0a70ece37a0199a0384}{attach\+\_\+data\+\_\+postprocessor\+\_\+domain} (const dealii\+::\+Data\+Postprocessor$<$ spacedim $>$ \&dp)
\item 
void \hyperlink{classincremental_f_e_1_1_f_e_model_a021c3223c447ac210a9c994abeaa7495}{attach\+\_\+data\+\_\+postprocessor\+\_\+interface} (const dealii\+::\+Data\+Postprocessor$<$ spacedim $>$ \&dp)
\item 
const Solution\+Vector\+Type \& \hyperlink{classincremental_f_e_1_1_f_e_model_ae9f26087df29cd1355aafbba17d7fedb}{get\+\_\+solution\+\_\+vector} () const 
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classincremental_f_e_1_1_f_e_model_ae792df01f91eab7c12ecf41b7e8c514b}{reinit\+\_\+solution\+\_\+vector} (Solution\+Vector\+Type \&vector)
\item 
void \hyperlink{classincremental_f_e_1_1_f_e_model_aa8f0eaa319c21a88310d813fb34213f6}{reinit\+\_\+rhs\+\_\+vector} (R\+H\+S\+Vector\+Type \&vector)
\item 
void \hyperlink{classincremental_f_e_1_1_f_e_model_aca9a1d1eb2233b6dbfac86e14a092729}{reinit\+\_\+matrix} (Matrix\+Type \&matrix)
\item 
bool \hyperlink{classincremental_f_e_1_1_f_e_model_a9ac2dbc4fdd4630cce4961a2360dc0f6}{compute\+\_\+system} (const Solution\+Vector\+Type \&solution\+\_\+ref, dealii\+::\+Affine\+Constraints$<$ double $>$ \&\hyperlink{classincremental_f_e_1_1_f_e_model_a33a622c3c53ea4bee3bdefac06201c70}{constraints})
\item 
void \hyperlink{classincremental_f_e_1_1_f_e_model_a7c5c84e081ebe20e373ec5d2abc359b7}{compute\+\_\+sparsity\+\_\+pattern} (const dealii\+::\+Affine\+Constraints$<$ double $>$ \&\hyperlink{classincremental_f_e_1_1_f_e_model_a33a622c3c53ea4bee3bdefac06201c70}{constraints})
\item 
void \hyperlink{classincremental_f_e_1_1_f_e_model_ae96fd0a7b6688ed844059d2636e923cc}{make\+\_\+constraints} (dealii\+::\+Affine\+Constraints$<$ double $>$ \&\hyperlink{classincremental_f_e_1_1_f_e_model_a33a622c3c53ea4bee3bdefac06201c70}{constraints}, const dealii\+::\+Affine\+Constraints$<$ double $>$ \&custom\+\_\+constraints=dealii\+::\+Affine\+Constraints$<$ double $>$(), const dealii\+::\+Affine\+Constraints$<$ double $>$ \&ignore\+\_\+constraints=dealii\+::\+Affine\+Constraints$<$ double $>$())
\item 
void \hyperlink{classincremental_f_e_1_1_f_e_model_a08717e3296b8b304ebaed4a67638dae3}{adjust\+\_\+constraint\+\_\+inhomogeneity} (dealii\+::\+Affine\+Constraints$<$ double $>$ \&\hyperlink{classincremental_f_e_1_1_f_e_model_a33a622c3c53ea4bee3bdefac06201c70}{constraints}) const 
\item 
void \hyperlink{classincremental_f_e_1_1_f_e_model_a42ff8db18960919cc440d0053e4d5891}{update\+\_\+rhs\+\_\+scaling\+\_\+vector} ()
\item 
double \hyperlink{classincremental_f_e_1_1_f_e_model_aa8f82250544410e43abf4812565bfc20}{compute\+\_\+estimated\+\_\+potential\+\_\+increment} (const Solution\+Vector\+Type \&delta\+\_\+solution) const 
\item 
void \hyperlink{classincremental_f_e_1_1_f_e_model_a3fcdba85d0abaca07655c094da98a497}{adjust\+\_\+delta\+\_\+solution} (Solution\+Vector\+Type \&delta\+\_\+solution, const Solution\+Vector\+Type \&solution\+\_\+ref, const dealii\+::\+Affine\+Constraints$<$ double $>$ \&\hyperlink{classincremental_f_e_1_1_f_e_model_a33a622c3c53ea4bee3bdefac06201c70}{constraints})
\item 
void \hyperlink{classincremental_f_e_1_1_f_e_model_a5ecf05b93871cc936364d85d990c80e0}{update\+\_\+ghosts} (Solution\+Vector\+Type \&vector)
\item 
void \hyperlink{classincremental_f_e_1_1_f_e_model_a0eb2401c8fde4bea7ed93527ee0e5f8a}{zero\+\_\+ghosts} (Solution\+Vector\+Type \&vector)
\item 
double \hyperlink{classincremental_f_e_1_1_f_e_model_abef0d6e47e00fb6b502d1b21cecc1766}{get\+\_\+residual} () const 
\item 
void \hyperlink{classincremental_f_e_1_1_f_e_model_ae06daeaed072ca50f43eccec359b3da3}{post\+\_\+refinement} ()
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
dealii\+::\+Galerkin\+Tools\+::\+Do\+F\+Renumbering\+Offset \hyperlink{classincremental_f_e_1_1_f_e_model_ae3bd54f0440c5dcaf08066efd786c341}{dof\+\_\+renumbering}
\item 
dealii\+::\+Galerkin\+Tools\+::\+Assembly\+Helper$<$ spacedim $>$ \hyperlink{classincremental_f_e_1_1_f_e_model_a937ea806f50796c76a45f36e6ec3cd29}{assembly\+\_\+helper}
\item 
const dealii\+::\+Smart\+Pointer$<$ \hyperlink{classincremental_f_e_1_1_global_data_incremental_f_e}{Global\+Data\+Incremental\+FE}$<$ spacedim $>$ $>$ \hyperlink{classincremental_f_e_1_1_f_e_model_aa6f80778241b26906af1f571517102dd}{global\+\_\+data}
\item 
const dealii\+::\+Smart\+Pointer$<$ const \hyperlink{classincremental_f_e_1_1_constraints}{Constraints}$<$ spacedim $>$ $>$ \hyperlink{classincremental_f_e_1_1_f_e_model_a33a622c3c53ea4bee3bdefac06201c70}{constraints}
\item 
const dealii\+::\+Smart\+Pointer$<$ const dealii\+::\+Galerkin\+Tools\+::\+Solver\+Wrapper$<$ Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type, dealii\+::\+Galerkin\+Tools\+::\+Two\+Block\+Sparsity\+Pattern $>$ $>$ \hyperlink{classincremental_f_e_1_1_f_e_model_a609de66ca9623d737bf3a45a37bb7690}{solver\+\_\+wrapper}
\item 
dealii\+::\+Galerkin\+Tools\+::\+Two\+Block\+Sparsity\+Pattern \hyperlink{classincremental_f_e_1_1_f_e_model_ac5c04f79916df3cc38ac64209051eecd}{sparsity\+\_\+pattern}
\item 
Matrix\+Type \hyperlink{classincremental_f_e_1_1_f_e_model_abc07b7d142d78230bcd55274f35514b3}{system\+\_\+matrix}
\item 
Solution\+Vector\+Type \hyperlink{classincremental_f_e_1_1_f_e_model_a02134975db38fcf4f7ce698d605baa30}{solution}
\item 
R\+H\+S\+Vector\+Type \hyperlink{classincremental_f_e_1_1_f_e_model_aba8e9e925aa72d2dd0f86c451b2cf3d6}{rhs}
\item 
double \hyperlink{classincremental_f_e_1_1_f_e_model_a04ea9240ef0084b44471a40f0d64ac54}{potential\+\_\+value} = 0.\+0
\item 
R\+H\+S\+Vector\+Type \hyperlink{classincremental_f_e_1_1_f_e_model_a26ffe7f5ecf94f3bdbe27f4ea3e577dc}{rhs\+\_\+scaling\+\_\+vector}
\item 
dealii\+::\+Affine\+Constraints$<$ double $>$ \hyperlink{classincremental_f_e_1_1_f_e_model_af333d1d12e78c27c74b033a85d075d38}{hanging\+\_\+node\+\_\+constraints}
\item 
dealii\+::\+Affine\+Constraints$<$ double $>$ \hyperlink{classincremental_f_e_1_1_f_e_model_a4ea39622157334a3d985c418a3b9ca34}{dirichlet\+\_\+constraints}
\item 
std\+::vector$<$ std\+::pair$<$ double, std\+::string $>$ $>$ \hyperlink{classincremental_f_e_1_1_f_e_model_a9a6cc0723bdeb129e330179ed4a87670}{times\+\_\+and\+\_\+names\+\_\+domain}
\item 
std\+::vector$<$ std\+::pair$<$ double, std\+::string $>$ $>$ \hyperlink{classincremental_f_e_1_1_f_e_model_aaa0e0ef1be909224dfe6f28484b9d754}{times\+\_\+and\+\_\+names\+\_\+interface}
\item 
std\+::vector$<$ boost\+::signals2\+::connection $>$ \hyperlink{classincremental_f_e_1_1_f_e_model_acf28a249a6d3800401624fc8bc8f3baf}{connections}
\item 
std\+::vector$<$ dealii\+::\+Smart\+Pointer$<$ const dealii\+::\+Data\+Postprocessor$<$ spacedim $>$ $>$ $>$ \hyperlink{classincremental_f_e_1_1_f_e_model_aff2f85b08282289389284138ca708eca}{dp\+\_\+domain}
\item 
std\+::vector$<$ dealii\+::\+Smart\+Pointer$<$ const dealii\+::\+Data\+Postprocessor$<$ spacedim $>$ $>$ $>$ \hyperlink{classincremental_f_e_1_1_f_e_model_adeb548ba39fe59036312bb8ba1d8cbf9}{dp\+\_\+interface}
\item 
const bool \hyperlink{classincremental_f_e_1_1_f_e_model_a65b5910cfba2feb26933ad451ceff628}{make\+\_\+hanging\+\_\+node\+\_\+constraints}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$\\*
class incremental\+F\+E\+::\+F\+E\+Model$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$}

Class for solution of non-\/linear, transient problems by one-\/step time integration.

The solution algorithm within a single time step is based on a Newton-\/\+Raphson scheme together with a residual based line search algorithm enhancing convergence.


\begin{DoxyTemplParams}{Template Parameters}
{\em Solution\+Vector\+Type} & the type used for the solution vector and the rhs, must be consistent with the {\bf Solver\+Wrapper} used (in parallel this vector type must permit read access to ghosted entries while write access is not required)\\
\hline
{\em R\+H\+S\+Vector\+Type} & the type used for the rhs, must be consistent with the {\bf Solver\+Wrapper} used (in parallel this vector type must permit write access to ghosted entries while read access is not required)\\
\hline
{\em Matrix\+Type} & the type used for the system matrix, must be consistent with the {\bf Solver\+Wrapper} used \\
\hline
\end{DoxyTemplParams}


\subsection{Constructor \& Destructor Documentation}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!F\+E\+Model@{F\+E\+Model}}
\index{F\+E\+Model@{F\+E\+Model}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{F\+E\+Model(const dealii\+::\+Galerkin\+Tools\+::\+Total\+Potential$<$ spacedim $>$ \&total\+\_\+potential, dealii\+::\+Galerkin\+Tools\+::\+Triangulation\+System$<$ spacedim $>$ \&tria\+\_\+system, const dealii\+::\+Mapping$<$ spacedim, spacedim $>$ \&mapping\+\_\+domain, const dealii\+::\+Mapping$<$ spacedim-\/1, spacedim $>$ \&mapping\+\_\+interface, Global\+Data\+Incremental\+F\+E$<$ spacedim $>$ \&global\+\_\+data, const Constraints$<$ spacedim $>$ \&constraints, const dealii\+::\+Galerkin\+Tools\+::\+Solver\+Wrapper$<$ Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type, dealii\+::\+Galerkin\+Tools\+::\+Two\+Block\+Sparsity\+Pattern $>$ \&solver\+\_\+wrapper, const bool make\+\_\+hanging\+\_\+node\+\_\+constraints=true)}{FEModel(const dealii::GalerkinTools::TotalPotential< spacedim > &total_potential, dealii::GalerkinTools::TriangulationSystem< spacedim > &tria_system, const dealii::Mapping< spacedim, spacedim > &mapping_domain, const dealii::Mapping< spacedim-1, spacedim > &mapping_interface, GlobalDataIncrementalFE< spacedim > &global_data, const Constraints< spacedim > &constraints, const dealii::GalerkinTools::SolverWrapper< SolutionVectorType, RHSVectorType, MatrixType, dealii::GalerkinTools::TwoBlockSparsityPattern > &solver_wrapper, const bool make_hanging_node_constraints=true)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::{\bf F\+E\+Model} (
\begin{DoxyParamCaption}
\item[{const dealii\+::\+Galerkin\+Tools\+::\+Total\+Potential$<$ spacedim $>$ \&}]{total\+\_\+potential, }
\item[{dealii\+::\+Galerkin\+Tools\+::\+Triangulation\+System$<$ spacedim $>$ \&}]{tria\+\_\+system, }
\item[{const dealii\+::\+Mapping$<$ spacedim, spacedim $>$ \&}]{mapping\+\_\+domain, }
\item[{const dealii\+::\+Mapping$<$ spacedim-\/1, spacedim $>$ \&}]{mapping\+\_\+interface, }
\item[{{\bf Global\+Data\+Incremental\+FE}$<$ spacedim $>$ \&}]{global\+\_\+data, }
\item[{const {\bf Constraints}$<$ spacedim $>$ \&}]{constraints, }
\item[{const dealii\+::\+Galerkin\+Tools\+::\+Solver\+Wrapper$<$ Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type, dealii\+::\+Galerkin\+Tools\+::\+Two\+Block\+Sparsity\+Pattern $>$ \&}]{solver\+\_\+wrapper, }
\item[{const bool}]{make\+\_\+hanging\+\_\+node\+\_\+constraints = {\ttfamily true}}
\end{DoxyParamCaption}
)}\hypertarget{classincremental_f_e_1_1_f_e_model_a230a5830a967893387b9010b9bd9b65b}{}\label{classincremental_f_e_1_1_f_e_model_a230a5830a967893387b9010b9bd9b65b}
Constructor


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em total\+\_\+potential} & {\bf Total\+Potential} object defining the total potential\\
\hline
\mbox{\tt in}  & {\em tria\+\_\+system} & {\bf Triangulation\+System} object\\
\hline
\mbox{\tt in}  & {\em mapping\+\_\+domain} & {\bf Mapping} to be used on the domain\\
\hline
\mbox{\tt in}  & {\em mapping\+\_\+interface} & {\bf Mapping} to be used on the interfaces\\
\hline
\mbox{\tt in}  & {\em global\+\_\+data} & The global data object to be used, see \hyperlink{classincremental_f_e_1_1_f_e_model_aa6f80778241b26906af1f571517102dd}{F\+E\+Model\+::global\+\_\+data}\\
\hline
\mbox{\tt in}  & {\em constraints} & \hyperlink{classincremental_f_e_1_1_constraints}{Constraints} object, see \hyperlink{classincremental_f_e_1_1_f_e_model_a33a622c3c53ea4bee3bdefac06201c70}{F\+E\+Model\+::constraints}\\
\hline
\mbox{\tt in}  & {\em solver\+\_\+wrapper} & {\bf Solver\+Wrapper} to be used, see \hyperlink{classincremental_f_e_1_1_f_e_model_a609de66ca9623d737bf3a45a37bb7690}{F\+E\+Model\+::solver\+\_\+wrapper}\\
\hline
\mbox{\tt in}  & {\em make\+\_\+hanging\+\_\+node\+\_\+constraints} & \hyperlink{classincremental_f_e_1_1_f_e_model_a65b5910cfba2feb26933ad451ceff628}{F\+E\+Model\+::make\+\_\+hanging\+\_\+node\+\_\+constraints} \\
\hline
\end{DoxyParams}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!````~F\+E\+Model@{$\sim$\+F\+E\+Model}}
\index{````~F\+E\+Model@{$\sim$\+F\+E\+Model}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{$\sim$\+F\+E\+Model()}{~FEModel()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::$\sim${\bf F\+E\+Model} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classincremental_f_e_1_1_f_e_model_ae4d9513474928ef225245928410f984b}{}\label{classincremental_f_e_1_1_f_e_model_ae4d9513474928ef225245928410f984b}
Destructor 

\subsection{Member Function Documentation}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!adjust\+\_\+constraint\+\_\+inhomogeneity@{adjust\+\_\+constraint\+\_\+inhomogeneity}}
\index{adjust\+\_\+constraint\+\_\+inhomogeneity@{adjust\+\_\+constraint\+\_\+inhomogeneity}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{adjust\+\_\+constraint\+\_\+inhomogeneity(dealii\+::\+Affine\+Constraints$<$ double $>$ \&constraints) const }{adjust_constraint_inhomogeneity(dealii::AffineConstraints< double > &constraints) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ void {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::adjust\+\_\+constraint\+\_\+inhomogeneity (
\begin{DoxyParamCaption}
\item[{dealii\+::\+Affine\+Constraints$<$ double $>$ \&}]{constraints}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_a08717e3296b8b304ebaed4a67638dae3}{}\label{classincremental_f_e_1_1_f_e_model_a08717e3296b8b304ebaed4a67638dae3}
Function adjusting constraint inhomogeneities associated with Dirichlet type constraints such that constraint object applies to solution increment and not to the solution itself \index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!adjust\+\_\+delta\+\_\+solution@{adjust\+\_\+delta\+\_\+solution}}
\index{adjust\+\_\+delta\+\_\+solution@{adjust\+\_\+delta\+\_\+solution}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{adjust\+\_\+delta\+\_\+solution(\+Solution\+Vector\+Type \&delta\+\_\+solution, const Solution\+Vector\+Type \&solution\+\_\+ref, const dealii\+::\+Affine\+Constraints$<$ double $>$ \&constraints)}{adjust_delta_solution(SolutionVectorType &delta_solution, const SolutionVectorType &solution_ref, const dealii::AffineConstraints< double > &constraints)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ void {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::adjust\+\_\+delta\+\_\+solution (
\begin{DoxyParamCaption}
\item[{Solution\+Vector\+Type \&}]{delta\+\_\+solution, }
\item[{const Solution\+Vector\+Type \&}]{solution\+\_\+ref, }
\item[{const dealii\+::\+Affine\+Constraints$<$ double $>$ \&}]{constraints}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_a3fcdba85d0abaca07655c094da98a497}{}\label{classincremental_f_e_1_1_f_e_model_a3fcdba85d0abaca07655c094da98a497}
Computes maximum allowable step size without obtaining inadmissible state and adjust {\ttfamily delta\+\_\+solution} accordingly. The \char`\"{}safety distance\char`\"{} to the domain of inadmissible states is specified by \hyperlink{classincremental_f_e_1_1_global_data_incremental_f_e_a6db92e8e97c6875df1ecf5aa2a3a0345}{Global\+Data\+Incremental\+F\+E\+::safety\+\_\+distance}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em delta\+\_\+solution} & increment direction\\
\hline
\mbox{\tt in}  & {\em solution\+\_\+ref} & reference solution\\
\hline
\mbox{\tt in}  & {\em constraints} & constraint matrix\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
maximum allowable step size 
\end{DoxyReturn}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!attach\+\_\+data\+\_\+postprocessor\+\_\+domain@{attach\+\_\+data\+\_\+postprocessor\+\_\+domain}}
\index{attach\+\_\+data\+\_\+postprocessor\+\_\+domain@{attach\+\_\+data\+\_\+postprocessor\+\_\+domain}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{attach\+\_\+data\+\_\+postprocessor\+\_\+domain(const dealii\+::\+Data\+Postprocessor$<$ spacedim $>$ \&dp)}{attach_data_postprocessor_domain(const dealii::DataPostprocessor< spacedim > &dp)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ void {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::attach\+\_\+data\+\_\+postprocessor\+\_\+domain (
\begin{DoxyParamCaption}
\item[{const dealii\+::\+Data\+Postprocessor$<$ spacedim $>$ \&}]{dp}
\end{DoxyParamCaption}
)}\hypertarget{classincremental_f_e_1_1_f_e_model_af838cd26f882b0a70ece37a0199a0384}{}\label{classincremental_f_e_1_1_f_e_model_af838cd26f882b0a70ece37a0199a0384}
Function attaching {\bf Data\+Postprocessor} for domain cells. The {\bf Data\+Postprocessor} objects attached are used in \hyperlink{classincremental_f_e_1_1_f_e_model_a2e13285d3ec061e14dacaaf174ee5bf5}{F\+E\+Model\+::write\+\_\+output\+\_\+independent\+\_\+fields()} to generate output.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em dp} & The {\bf Data\+Postprocessor} object \\
\hline
\end{DoxyParams}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!attach\+\_\+data\+\_\+postprocessor\+\_\+interface@{attach\+\_\+data\+\_\+postprocessor\+\_\+interface}}
\index{attach\+\_\+data\+\_\+postprocessor\+\_\+interface@{attach\+\_\+data\+\_\+postprocessor\+\_\+interface}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{attach\+\_\+data\+\_\+postprocessor\+\_\+interface(const dealii\+::\+Data\+Postprocessor$<$ spacedim $>$ \&dp)}{attach_data_postprocessor_interface(const dealii::DataPostprocessor< spacedim > &dp)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ void {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::attach\+\_\+data\+\_\+postprocessor\+\_\+interface (
\begin{DoxyParamCaption}
\item[{const dealii\+::\+Data\+Postprocessor$<$ spacedim $>$ \&}]{dp}
\end{DoxyParamCaption}
)}\hypertarget{classincremental_f_e_1_1_f_e_model_a021c3223c447ac210a9c994abeaa7495}{}\label{classincremental_f_e_1_1_f_e_model_a021c3223c447ac210a9c994abeaa7495}
Function attaching {\bf Data\+Postprocessor} for interface cells. The {\bf Data\+Postprocessor} objects attached are used in \hyperlink{classincremental_f_e_1_1_f_e_model_a2e13285d3ec061e14dacaaf174ee5bf5}{F\+E\+Model\+::write\+\_\+output\+\_\+independent\+\_\+fields()} to generate output.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em dp} & The {\bf Data\+Postprocessor} object \\
\hline
\end{DoxyParams}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!compute\+\_\+distance\+\_\+to\+\_\+exact\+\_\+solution@{compute\+\_\+distance\+\_\+to\+\_\+exact\+\_\+solution}}
\index{compute\+\_\+distance\+\_\+to\+\_\+exact\+\_\+solution@{compute\+\_\+distance\+\_\+to\+\_\+exact\+\_\+solution}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{compute\+\_\+distance\+\_\+to\+\_\+exact\+\_\+solution(const dealii\+::\+Function$<$ spacedim $>$ \&exact\+\_\+solution\+\_\+domain, const dealii\+::\+Function$<$ spacedim $>$ \&exact\+\_\+solution\+\_\+interface, const dealii\+::\+Quadrature$<$ spacedim $>$ quadrature\+\_\+domain, const dealii\+::\+Quadrature$<$ spacedim-\/1 $>$ quadrature\+\_\+interface, const dealii\+::\+Vector\+Tools\+::\+Norm\+Type norm\+\_\+type=dealii\+::\+Vector\+Tools\+::\+Norm\+Type\+::\+L2\+\_\+norm, const dealii\+::\+Component\+Mask component\+\_\+mask\+\_\+domain=dealii\+::\+Component\+Mask(), const dealii\+::\+Component\+Mask component\+\_\+mask\+\_\+interface=dealii\+::\+Component\+Mask(), const double exponent=2.\+0) const }{compute_distance_to_exact_solution(const dealii::Function< spacedim > &exact_solution_domain, const dealii::Function< spacedim > &exact_solution_interface, const dealii::Quadrature< spacedim > quadrature_domain, const dealii::Quadrature< spacedim-1 > quadrature_interface, const dealii::VectorTools::NormType norm_type=dealii::VectorTools::NormType::L2_norm, const dealii::ComponentMask component_mask_domain=dealii::ComponentMask(), const dealii::ComponentMask component_mask_interface=dealii::ComponentMask(), const double exponent=2.0) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ std\+::pair$<$const double, const double$>$ {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::compute\+\_\+distance\+\_\+to\+\_\+exact\+\_\+solution (
\begin{DoxyParamCaption}
\item[{const dealii\+::\+Function$<$ spacedim $>$ \&}]{exact\+\_\+solution\+\_\+domain, }
\item[{const dealii\+::\+Function$<$ spacedim $>$ \&}]{exact\+\_\+solution\+\_\+interface, }
\item[{const dealii\+::\+Quadrature$<$ spacedim $>$}]{quadrature\+\_\+domain, }
\item[{const dealii\+::\+Quadrature$<$ spacedim-\/1 $>$}]{quadrature\+\_\+interface, }
\item[{const {\bf dealii\+::\+Vector\+Tools\+::\+Norm\+Type}}]{norm\+\_\+type = {\ttfamily dealii\+:\+:VectorTools\+:\+:NormType\+:\+:L2\+\_\+norm}, }
\item[{const dealii\+::\+Component\+Mask}]{component\+\_\+mask\+\_\+domain = {\ttfamily dealii\+:\+:ComponentMask()}, }
\item[{const dealii\+::\+Component\+Mask}]{component\+\_\+mask\+\_\+interface = {\ttfamily dealii\+:\+:ComponentMask()}, }
\item[{const double}]{exponent = {\ttfamily 2.0}}
\end{DoxyParamCaption}
) const}\hypertarget{classincremental_f_e_1_1_f_e_model_ae785f6ada313fec0811414e3f4294faf}{}\label{classincremental_f_e_1_1_f_e_model_ae785f6ada313fec0811414e3f4294faf}
Function computing the \char`\"{}distance\char`\"{} of the solution vector \hyperlink{classincremental_f_e_1_1_f_e_model_a02134975db38fcf4f7ce698d605baa30}{F\+E\+Model\+::solution} to an exact solution.

The exact and the numerical solution are subtracted and finally the norm of the resulting difference is computed numerically. This is done for the domain related and the interface related part separately.

Note that the values of the independent scalars are currently not taken into account in this method.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em exact\+\_\+solution\+\_\+domain} & Exact solution on domain (use {\bf Assembly\+Helper\+::get\+\_\+u\+\_\+omega\+\_\+global\+\_\+component\+\_\+indices()} to obtain information about the component indexing; the underlying {\bf Assembly\+Helper} needed for this can be obtained by \hyperlink{classincremental_f_e_1_1_f_e_model_a32bc459c2816503c0b70a4f1a6730917}{F\+E\+Model\+::get\+\_\+assembly\+\_\+helper()})\\
\hline
\mbox{\tt in}  & {\em exact\+\_\+solution\+\_\+interface} & Exact solution on interface (use {\bf Assembly\+Helper\+::get\+\_\+u\+\_\+sigma\+\_\+global\+\_\+component\+\_\+indices()} to obtain information about the component indexing; the underlying {\bf Assembly\+Helper} needed for this can be obtained by \hyperlink{classincremental_f_e_1_1_f_e_model_a32bc459c2816503c0b70a4f1a6730917}{F\+E\+Model\+::get\+\_\+assembly\+\_\+helper()})\\
\hline
\mbox{\tt in}  & {\em quadrature\+\_\+domain} & {\bf Quadrature} scheme to be used on the domain for the computation of the norm\\
\hline
\mbox{\tt in}  & {\em quadrature\+\_\+interface} & {\bf Quadrature} scheme to be used on the interface for the computation of the norm\\
\hline
\mbox{\tt in}  & {\em norm\+\_\+type} & Type of the norm\\
\hline
\mbox{\tt in}  & {\em component\+\_\+mask\+\_\+domain} & Domain related solution components to be included in the calculation. If the {\bf Component\+Mask} is empty, all components will be included\\
\hline
\mbox{\tt in}  & {\em component\+\_\+mask\+\_\+interface} & Domain related solution components to be included in the calculation. If the {\bf Component\+Mask} is empty, all components will be included\\
\hline
\mbox{\tt in}  & {\em exponent} & Exponent of the norm if required\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The value of the norm computed on the domain and the interface, respectively 
\end{DoxyReturn}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!compute\+\_\+distance\+\_\+to\+\_\+other\+\_\+solution@{compute\+\_\+distance\+\_\+to\+\_\+other\+\_\+solution}}
\index{compute\+\_\+distance\+\_\+to\+\_\+other\+\_\+solution@{compute\+\_\+distance\+\_\+to\+\_\+other\+\_\+solution}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{compute\+\_\+distance\+\_\+to\+\_\+other\+\_\+solution(const F\+E\+Model$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$ \&other\+\_\+incremental\+\_\+fe, const dealii\+::\+Quadrature$<$ spacedim $>$ quadrature\+\_\+domain, const dealii\+::\+Quadrature$<$ spacedim-\/1 $>$ quadrature\+\_\+interface, const dealii\+::\+Vector\+Tools\+::\+Norm\+Type norm\+\_\+type=dealii\+::\+Vector\+Tools\+::\+Norm\+Type\+::\+L2\+\_\+norm, const dealii\+::\+Component\+Mask component\+\_\+mask\+\_\+domain=dealii\+::\+Component\+Mask(), const dealii\+::\+Component\+Mask component\+\_\+mask\+\_\+interface=dealii\+::\+Component\+Mask(), const double exponent=2.) const }{compute_distance_to_other_solution(const FEModel< spacedim, SolutionVectorType, RHSVectorType, MatrixType > &other_incremental_fe, const dealii::Quadrature< spacedim > quadrature_domain, const dealii::Quadrature< spacedim-1 > quadrature_interface, const dealii::VectorTools::NormType norm_type=dealii::VectorTools::NormType::L2_norm, const dealii::ComponentMask component_mask_domain=dealii::ComponentMask(), const dealii::ComponentMask component_mask_interface=dealii::ComponentMask(), const double exponent=2.) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ std\+::pair$<$const double, const double$>$ {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::compute\+\_\+distance\+\_\+to\+\_\+other\+\_\+solution (
\begin{DoxyParamCaption}
\item[{const {\bf F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$ \&}]{other\+\_\+incremental\+\_\+fe, }
\item[{const dealii\+::\+Quadrature$<$ spacedim $>$}]{quadrature\+\_\+domain, }
\item[{const dealii\+::\+Quadrature$<$ spacedim-\/1 $>$}]{quadrature\+\_\+interface, }
\item[{const {\bf dealii\+::\+Vector\+Tools\+::\+Norm\+Type}}]{norm\+\_\+type = {\ttfamily dealii\+:\+:VectorTools\+:\+:NormType\+:\+:L2\+\_\+norm}, }
\item[{const dealii\+::\+Component\+Mask}]{component\+\_\+mask\+\_\+domain = {\ttfamily dealii\+:\+:ComponentMask()}, }
\item[{const dealii\+::\+Component\+Mask}]{component\+\_\+mask\+\_\+interface = {\ttfamily dealii\+:\+:ComponentMask()}, }
\item[{const double}]{exponent = {\ttfamily 2.}}
\end{DoxyParamCaption}
) const}\hypertarget{classincremental_f_e_1_1_f_e_model_af3c39fb15e308e6979b55fc4b988b3a2}{}\label{classincremental_f_e_1_1_f_e_model_af3c39fb15e308e6979b55fc4b988b3a2}
Function computing the \char`\"{}distance\char`\"{} of the solution vector \hyperlink{classincremental_f_e_1_1_f_e_model_a02134975db38fcf4f7ce698d605baa30}{F\+E\+Model\+::solution} of this \hyperlink{classincremental_f_e_1_1_f_e_model}{F\+E\+Model} to the solution vector \hyperlink{classincremental_f_e_1_1_f_e_model_a02134975db38fcf4f7ce698d605baa30}{F\+E\+Model\+::solution} of another \hyperlink{classincremental_f_e_1_1_f_e_model}{F\+E\+Model} (the \hyperlink{classincremental_f_e_1_1_f_e_model}{F\+E\+Model} objects must be the same apart from the mesh refinement, in particular they must be based on the same coarse mesh).

Note that the values of the independent scalars are currently not taken into account in this method.

For further details see {\bf Assembly\+Helper\+::compute\+\_\+distance\+\_\+to\+\_\+other\+\_\+solution()}.

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000001}{Todo}]Hanging node constraints are currently not taken care of when comparing the solutions. Also not all {\bf Vector\+Tools\+::\+Norm\+Type} norms are implemented yet.\end{DoxyRefDesc}



\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em other\+\_\+incremental\+\_\+fe} & The other \hyperlink{classincremental_f_e_1_1_f_e_model}{F\+E\+Model} object\\
\hline
\mbox{\tt in}  & {\em quadrature\+\_\+domain} & {\bf Quadrature} scheme to be used on the domain for the computation of the norm\\
\hline
\mbox{\tt in}  & {\em quadrature\+\_\+interface} & {\bf Quadrature} scheme to be used on the interface for the computation of the norm\\
\hline
\mbox{\tt in}  & {\em norm\+\_\+type} & Type of the norm (note\+: currently only {\bf Vector\+Tools\+::\+Norm\+Type}\+:\+:{\ttfamily L2\+\_\+norm} and {\bf Vector\+Tools\+::\+Norm\+Type}\+:\+:{\ttfamily Linfty\+\_\+norm} are implemented)\\
\hline
\mbox{\tt in}  & {\em component\+\_\+mask\+\_\+domain} & Domain related solution components to be included in the calculation. If the {\bf Component\+Mask} is empty, all components will be included\\
\hline
\mbox{\tt in}  & {\em component\+\_\+mask\+\_\+interface} & Domain related solution components to be included in the calculation. If the {\bf Component\+Mask} is empty, all components will be included\\
\hline
\mbox{\tt in}  & {\em exponent} & Exponent of the norm if required. Currently this is unused because no norms with variable exponent are implemented.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The value of the norm computed on the domain and the interface, respectively 
\end{DoxyReturn}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!compute\+\_\+estimated\+\_\+potential\+\_\+increment@{compute\+\_\+estimated\+\_\+potential\+\_\+increment}}
\index{compute\+\_\+estimated\+\_\+potential\+\_\+increment@{compute\+\_\+estimated\+\_\+potential\+\_\+increment}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{compute\+\_\+estimated\+\_\+potential\+\_\+increment(const Solution\+Vector\+Type \&delta\+\_\+solution) const }{compute_estimated_potential_increment(const SolutionVectorType &delta_solution) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ double {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::compute\+\_\+estimated\+\_\+potential\+\_\+increment (
\begin{DoxyParamCaption}
\item[{const Solution\+Vector\+Type \&}]{delta\+\_\+solution}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_aa8f82250544410e43abf4812565bfc20}{}\label{classincremental_f_e_1_1_f_e_model_aa8f82250544410e43abf4812565bfc20}
computes estimated potential increment (inner product between {\ttfamily delta\+\_\+solution} and \hyperlink{classincremental_f_e_1_1_f_e_model_aba8e9e925aa72d2dd0f86c451b2cf3d6}{F\+E\+Model\+::rhs})


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em delta\+\_\+solution} & solution increment\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
estimated potential increment 
\end{DoxyReturn}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!compute\+\_\+sparsity\+\_\+pattern@{compute\+\_\+sparsity\+\_\+pattern}}
\index{compute\+\_\+sparsity\+\_\+pattern@{compute\+\_\+sparsity\+\_\+pattern}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{compute\+\_\+sparsity\+\_\+pattern(const dealii\+::\+Affine\+Constraints$<$ double $>$ \&constraints)}{compute_sparsity_pattern(const dealii::AffineConstraints< double > &constraints)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ void {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::compute\+\_\+sparsity\+\_\+pattern (
\begin{DoxyParamCaption}
\item[{const dealii\+::\+Affine\+Constraints$<$ double $>$ \&}]{constraints}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_a7c5c84e081ebe20e373ec5d2abc359b7}{}\label{classincremental_f_e_1_1_f_e_model_a7c5c84e081ebe20e373ec5d2abc359b7}
Function computing the \hyperlink{classincremental_f_e_1_1_f_e_model_ac5c04f79916df3cc38ac64209051eecd}{F\+E\+Model\+::sparsity\+\_\+pattern}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em constraints} & \hyperlink{classincremental_f_e_1_1_constraints}{Constraints} to be taken into account \\
\hline
\end{DoxyParams}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!compute\+\_\+system@{compute\+\_\+system}}
\index{compute\+\_\+system@{compute\+\_\+system}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{compute\+\_\+system(const Solution\+Vector\+Type \&solution\+\_\+ref, dealii\+::\+Affine\+Constraints$<$ double $>$ \&constraints)}{compute_system(const SolutionVectorType &solution_ref, dealii::AffineConstraints< double > &constraints)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ bool {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::compute\+\_\+system (
\begin{DoxyParamCaption}
\item[{const Solution\+Vector\+Type \&}]{solution\+\_\+ref, }
\item[{dealii\+::\+Affine\+Constraints$<$ double $>$ \&}]{constraints}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_a9ac2dbc4fdd4630cce4961a2360dc0f6}{}\label{classincremental_f_e_1_1_f_e_model_a9ac2dbc4fdd4630cce4961a2360dc0f6}
Function computing current \hyperlink{classincremental_f_e_1_1_f_e_model_aba8e9e925aa72d2dd0f86c451b2cf3d6}{F\+E\+Model\+::rhs} and \hyperlink{classincremental_f_e_1_1_f_e_model_abc07b7d142d78230bcd55274f35514b3}{F\+E\+Model\+::system\+\_\+matrix}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em solution\+\_\+ref} & The reference solution vector\\
\hline
\mbox{\tt in}  & {\em constraints} & The constraints object\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true\+:} error, {\ttfamily false\+:} no error 
\end{DoxyReturn}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!do\+\_\+time\+\_\+step@{do\+\_\+time\+\_\+step}}
\index{do\+\_\+time\+\_\+step@{do\+\_\+time\+\_\+step}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{do\+\_\+time\+\_\+step(const double t, const dealii\+::\+Affine\+Constraints$<$ double $>$ \&custom\+\_\+constraints=dealii\+::\+Affine\+Constraints$<$ double $>$(), const dealii\+::\+Affine\+Constraints$<$ double $>$ \&ignore\+\_\+constraints=dealii\+::\+Affine\+Constraints$<$ double $>$())}{do_time_step(const double t, const dealii::AffineConstraints< double > &custom_constraints=dealii::AffineConstraints< double >(), const dealii::AffineConstraints< double > &ignore_constraints=dealii::AffineConstraints< double >())}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ int {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::do\+\_\+time\+\_\+step (
\begin{DoxyParamCaption}
\item[{const double}]{t, }
\item[{const dealii\+::\+Affine\+Constraints$<$ double $>$ \&}]{custom\+\_\+constraints = {\ttfamily dealii\+:\+:AffineConstraints$<$~double~$>$()}, }
\item[{const dealii\+::\+Affine\+Constraints$<$ double $>$ \&}]{ignore\+\_\+constraints = {\ttfamily dealii\+:\+:AffineConstraints$<$~double~$>$()}}
\end{DoxyParamCaption}
)}\hypertarget{classincremental_f_e_1_1_f_e_model_a1528bdeba89d6f4774526a2ed9412047}{}\label{classincremental_f_e_1_1_f_e_model_a1528bdeba89d6f4774526a2ed9412047}
Method to compute a single time step


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em t} & new time\\
\hline
\mbox{\tt in}  & {\em custom\+\_\+constraints} & \hyperlink{classincremental_f_e_1_1_constraints}{Constraints} additional to \hyperlink{classincremental_f_e_1_1_f_e_model_a33a622c3c53ea4bee3bdefac06201c70}{F\+E\+Model\+::constraints} to be taken into consideration (should be closed). This allows e.\+g. for constraints prescribing individual dofs (e.\+g. to fix a pressure variable)\\
\hline
\mbox{\tt in}  & {\em ignore\+\_\+constraints} & \hyperlink{classincremental_f_e_1_1_constraints}{Constraints} object with constraint lines to be ignored. This allows e.\+g. to eliminate overconstraints at individual vertices resulting e.\+g. from different constraints imposed on different portions of the boundary.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of Newton-\/\+Raphson iterations required for time step, returns -\/1 if no convergence or other error 
\end{DoxyReturn}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!get\+\_\+assembly\+\_\+helper@{get\+\_\+assembly\+\_\+helper}}
\index{get\+\_\+assembly\+\_\+helper@{get\+\_\+assembly\+\_\+helper}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{get\+\_\+assembly\+\_\+helper()}{get_assembly_helper()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ const dealii\+::\+Galerkin\+Tools\+::\+Assembly\+Helper$<$spacedim$>$\& {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::get\+\_\+assembly\+\_\+helper (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classincremental_f_e_1_1_f_e_model_a32bc459c2816503c0b70a4f1a6730917}{}\label{classincremental_f_e_1_1_f_e_model_a32bc459c2816503c0b70a4f1a6730917}
\begin{DoxyReturn}{Returns}
the \hyperlink{classincremental_f_e_1_1_f_e_model_a937ea806f50796c76a45f36e6ec3cd29}{F\+E\+Model\+::assembly\+\_\+helper} object 
\end{DoxyReturn}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!get\+\_\+potential\+\_\+value@{get\+\_\+potential\+\_\+value}}
\index{get\+\_\+potential\+\_\+value@{get\+\_\+potential\+\_\+value}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{get\+\_\+potential\+\_\+value() const }{get_potential_value() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ double {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::get\+\_\+potential\+\_\+value (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classincremental_f_e_1_1_f_e_model_ab557cb22e2a0bd89cc7f0c2d048524ba}{}\label{classincremental_f_e_1_1_f_e_model_ab557cb22e2a0bd89cc7f0c2d048524ba}
\begin{DoxyReturn}{Returns}
\hyperlink{classincremental_f_e_1_1_f_e_model_a04ea9240ef0084b44471a40f0d64ac54}{F\+E\+Model\+::potential\+\_\+value} 
\end{DoxyReturn}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!get\+\_\+residual@{get\+\_\+residual}}
\index{get\+\_\+residual@{get\+\_\+residual}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{get\+\_\+residual() const }{get_residual() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ double {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::get\+\_\+residual (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_abef0d6e47e00fb6b502d1b21cecc1766}{}\label{classincremental_f_e_1_1_f_e_model_abef0d6e47e00fb6b502d1b21cecc1766}
\begin{DoxyReturn}{Returns}
The 2-\/norm of the scaled version of \hyperlink{classincremental_f_e_1_1_f_e_model_aba8e9e925aa72d2dd0f86c451b2cf3d6}{F\+E\+Model\+::rhs}, for details regarding the scaling see \hyperlink{classincremental_f_e_1_1_f_e_model_a26ffe7f5ecf94f3bdbe27f4ea3e577dc}{F\+E\+Model\+::rhs\+\_\+scaling\+\_\+vector} 
\end{DoxyReturn}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!get\+\_\+solution\+\_\+vector@{get\+\_\+solution\+\_\+vector}}
\index{get\+\_\+solution\+\_\+vector@{get\+\_\+solution\+\_\+vector}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{get\+\_\+solution\+\_\+vector() const }{get_solution_vector() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ const Solution\+Vector\+Type\& {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::get\+\_\+solution\+\_\+vector (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classincremental_f_e_1_1_f_e_model_ae9f26087df29cd1355aafbba17d7fedb}{}\label{classincremental_f_e_1_1_f_e_model_ae9f26087df29cd1355aafbba17d7fedb}
\begin{DoxyReturn}{Returns}
const reference to solution vector 
\end{DoxyReturn}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!make\+\_\+constraints@{make\+\_\+constraints}}
\index{make\+\_\+constraints@{make\+\_\+constraints}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{make\+\_\+constraints(dealii\+::\+Affine\+Constraints$<$ double $>$ \&constraints, const dealii\+::\+Affine\+Constraints$<$ double $>$ \&custom\+\_\+constraints=dealii\+::\+Affine\+Constraints$<$ double $>$(), const dealii\+::\+Affine\+Constraints$<$ double $>$ \&ignore\+\_\+constraints=dealii\+::\+Affine\+Constraints$<$ double $>$())}{make_constraints(dealii::AffineConstraints< double > &constraints, const dealii::AffineConstraints< double > &custom_constraints=dealii::AffineConstraints< double >(), const dealii::AffineConstraints< double > &ignore_constraints=dealii::AffineConstraints< double >())}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ void {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::make\+\_\+constraints (
\begin{DoxyParamCaption}
\item[{dealii\+::\+Affine\+Constraints$<$ double $>$ \&}]{constraints, }
\item[{const dealii\+::\+Affine\+Constraints$<$ double $>$ \&}]{custom\+\_\+constraints = {\ttfamily dealii\+:\+:AffineConstraints$<$~double~$>$()}, }
\item[{const dealii\+::\+Affine\+Constraints$<$ double $>$ \&}]{ignore\+\_\+constraints = {\ttfamily dealii\+:\+:AffineConstraints$<$~double~$>$()}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_ae96fd0a7b6688ed844059d2636e923cc}{}\label{classincremental_f_e_1_1_f_e_model_ae96fd0a7b6688ed844059d2636e923cc}
Function assembling constraints (combines Dirichlet type constraints, hanging node constraints, custom constraints while taking into account the constraints to be ignored)

Updates also \hyperlink{classincremental_f_e_1_1_f_e_model_a4ea39622157334a3d985c418a3b9ca34}{F\+E\+Model\+::dirichlet\+\_\+constraints}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em constraints} & The resulting constraints object\\
\hline
\mbox{\tt in}  & {\em custom\+\_\+constraints} & \hyperlink{classincremental_f_e_1_1_constraints}{Constraints} additional to \hyperlink{classincremental_f_e_1_1_f_e_model_a33a622c3c53ea4bee3bdefac06201c70}{F\+E\+Model\+::constraints} to be taken into consideration (should be closed). This allows e.\+g. for constraints prescribing individual dofs (e.\+g. to fix a pressure variable)\\
\hline
\mbox{\tt in}  & {\em ignore\+\_\+constraints} & \hyperlink{classincremental_f_e_1_1_constraints}{Constraints} object with constraint lines to be ignored. This allows e.\+g. to eliminate overconstraints at individual vertices resulting e.\+g. from different constraints imposed on different portions of the boundary. \\
\hline
\end{DoxyParams}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!post\+\_\+refinement@{post\+\_\+refinement}}
\index{post\+\_\+refinement@{post\+\_\+refinement}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{post\+\_\+refinement()}{post_refinement()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ void {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::post\+\_\+refinement (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_ae06daeaed072ca50f43eccec359b3da3}{}\label{classincremental_f_e_1_1_f_e_model_ae06daeaed072ca50f43eccec359b3da3}
Function called automatically after the triangulation system is changed \index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!read\+\_\+solution\+\_\+from\+\_\+file@{read\+\_\+solution\+\_\+from\+\_\+file}}
\index{read\+\_\+solution\+\_\+from\+\_\+file@{read\+\_\+solution\+\_\+from\+\_\+file}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{read\+\_\+solution\+\_\+from\+\_\+file(const std\+::string file\+\_\+name)}{read_solution_from_file(const std::string file_name)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ void {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::read\+\_\+solution\+\_\+from\+\_\+file (
\begin{DoxyParamCaption}
\item[{const std\+::string}]{file\+\_\+name}
\end{DoxyParamCaption}
)}\hypertarget{classincremental_f_e_1_1_f_e_model_acb0d11f9d7a71971732d041a5cb4376a}{}\label{classincremental_f_e_1_1_f_e_model_acb0d11f9d7a71971732d041a5cb4376a}
Reads the solution vector from a file


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+\_\+name} & Name of the file to be read from (including extension)\\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
This function does nothing apart from reading the solution vector previously stored with \hyperlink{classincremental_f_e_1_1_f_e_model_a7dd3d4c235f2fd04a41184892e319601}{F\+E\+Model\+::write\+\_\+solution\+\_\+to\+\_\+file} back into the solution vector. It is the user\textquotesingle{}s responsibility that the \hyperlink{classincremental_f_e_1_1_f_e_model}{F\+E\+Model} is left in a usable state afterwards. In particular, no checking for the size of the solution vector or for the satisfaction of constraints is done. Also, this function does not read in the values of the hidden variables at the material points. Essentially, the purpose of this function is to make a computed solution available for post-\/processing without having to repeat the entire solution process. In particular, this function is not meant for restarting an analysis at a certain point. 
\end{DoxyWarning}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!reinit\+\_\+matrix@{reinit\+\_\+matrix}}
\index{reinit\+\_\+matrix@{reinit\+\_\+matrix}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{reinit\+\_\+matrix(\+Matrix\+Type \&matrix)}{reinit_matrix(MatrixType &matrix)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ void {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::reinit\+\_\+matrix (
\begin{DoxyParamCaption}
\item[{Matrix\+Type \&}]{matrix}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_aca9a1d1eb2233b6dbfac86e14a092729}{}\label{classincremental_f_e_1_1_f_e_model_aca9a1d1eb2233b6dbfac86e14a092729}
Reinit a system matrix


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em matrix} & The system matrix to be re-\/inited \\
\hline
\end{DoxyParams}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!reinit\+\_\+rhs\+\_\+vector@{reinit\+\_\+rhs\+\_\+vector}}
\index{reinit\+\_\+rhs\+\_\+vector@{reinit\+\_\+rhs\+\_\+vector}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{reinit\+\_\+rhs\+\_\+vector(\+R\+H\+S\+Vector\+Type \&vector)}{reinit_rhs_vector(RHSVectorType &vector)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ void {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::reinit\+\_\+rhs\+\_\+vector (
\begin{DoxyParamCaption}
\item[{R\+H\+S\+Vector\+Type \&}]{vector}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_aa8f0eaa319c21a88310d813fb34213f6}{}\label{classincremental_f_e_1_1_f_e_model_aa8f0eaa319c21a88310d813fb34213f6}
Reinit a rhs type vector


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em vector} & The vector to be re-\/inited \\
\hline
\end{DoxyParams}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!reinit\+\_\+solution\+\_\+vector@{reinit\+\_\+solution\+\_\+vector}}
\index{reinit\+\_\+solution\+\_\+vector@{reinit\+\_\+solution\+\_\+vector}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{reinit\+\_\+solution\+\_\+vector(\+Solution\+Vector\+Type \&vector)}{reinit_solution_vector(SolutionVectorType &vector)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ void {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::reinit\+\_\+solution\+\_\+vector (
\begin{DoxyParamCaption}
\item[{Solution\+Vector\+Type \&}]{vector}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_ae792df01f91eab7c12ecf41b7e8c514b}{}\label{classincremental_f_e_1_1_f_e_model_ae792df01f91eab7c12ecf41b7e8c514b}
Reinit a solution type vector


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em vector} & The vector to be re-\/inited \\
\hline
\end{DoxyParams}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!update\+\_\+ghosts@{update\+\_\+ghosts}}
\index{update\+\_\+ghosts@{update\+\_\+ghosts}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{update\+\_\+ghosts(\+Solution\+Vector\+Type \&vector)}{update_ghosts(SolutionVectorType &vector)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ void {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::update\+\_\+ghosts (
\begin{DoxyParamCaption}
\item[{Solution\+Vector\+Type \&}]{vector}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_a5ecf05b93871cc936364d85d990c80e0}{}\label{classincremental_f_e_1_1_f_e_model_a5ecf05b93871cc936364d85d990c80e0}
Update the ghost values of {\ttfamily vector} 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em vector} & The vector for which the ghost values are to be imported \\
\hline
\end{DoxyParams}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!update\+\_\+rhs\+\_\+scaling\+\_\+vector@{update\+\_\+rhs\+\_\+scaling\+\_\+vector}}
\index{update\+\_\+rhs\+\_\+scaling\+\_\+vector@{update\+\_\+rhs\+\_\+scaling\+\_\+vector}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{update\+\_\+rhs\+\_\+scaling\+\_\+vector()}{update_rhs_scaling_vector()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ void {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::update\+\_\+rhs\+\_\+scaling\+\_\+vector (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_a42ff8db18960919cc440d0053e4d5891}{}\label{classincremental_f_e_1_1_f_e_model_a42ff8db18960919cc440d0053e4d5891}
Function updating \hyperlink{classincremental_f_e_1_1_f_e_model_a26ffe7f5ecf94f3bdbe27f4ea3e577dc}{F\+E\+Model\+::rhs\+\_\+scaling\+\_\+vector} according to current \hyperlink{classincremental_f_e_1_1_f_e_model_abc07b7d142d78230bcd55274f35514b3}{F\+E\+Model\+::system\+\_\+matrix} \index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!write\+\_\+output\+\_\+independent\+\_\+fields@{write\+\_\+output\+\_\+independent\+\_\+fields}}
\index{write\+\_\+output\+\_\+independent\+\_\+fields@{write\+\_\+output\+\_\+independent\+\_\+fields}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{write\+\_\+output\+\_\+independent\+\_\+fields(const std\+::string file\+\_\+name\+\_\+domain, const std\+::string file\+\_\+name\+\_\+interface, const unsigned int n\+\_\+subdivisions=1)}{write_output_independent_fields(const std::string file_name_domain, const std::string file_name_interface, const unsigned int n_subdivisions=1)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ void {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::write\+\_\+output\+\_\+independent\+\_\+fields (
\begin{DoxyParamCaption}
\item[{const std\+::string}]{file\+\_\+name\+\_\+domain, }
\item[{const std\+::string}]{file\+\_\+name\+\_\+interface, }
\item[{const unsigned int}]{n\+\_\+subdivisions = {\ttfamily 1}}
\end{DoxyParamCaption}
)}\hypertarget{classincremental_f_e_1_1_f_e_model_a2e13285d3ec061e14dacaaf174ee5bf5}{}\label{classincremental_f_e_1_1_f_e_model_a2e13285d3ec061e14dacaaf174ee5bf5}
Function to write independent field output. The output is written to $\ast$.vtu files (one for domain related output and one for interface related output). Generally, the time step number is appended to the file names provided to this function. In addition, $\ast$.pvd records are written for the domain related output and the interface related output (file names according to the input parameters of this function).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+\_\+name\+\_\+domain} & File name (without extension) for independent field output on domain\\
\hline
\mbox{\tt in}  & {\em file\+\_\+name\+\_\+interface} & File name (without extension) for independent field output on interfaces\\
\hline
\mbox{\tt in}  & {\em n\+\_\+subdivisions} & The number of subdivisions of each cell (to get a better representation in case of curved inner cells, higher order elements, etc.) \\
\hline
\end{DoxyParams}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!write\+\_\+solution\+\_\+to\+\_\+file@{write\+\_\+solution\+\_\+to\+\_\+file}}
\index{write\+\_\+solution\+\_\+to\+\_\+file@{write\+\_\+solution\+\_\+to\+\_\+file}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{write\+\_\+solution\+\_\+to\+\_\+file(const std\+::string file\+\_\+name) const }{write_solution_to_file(const std::string file_name) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ void {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::write\+\_\+solution\+\_\+to\+\_\+file (
\begin{DoxyParamCaption}
\item[{const std\+::string}]{file\+\_\+name}
\end{DoxyParamCaption}
) const}\hypertarget{classincremental_f_e_1_1_f_e_model_a7dd3d4c235f2fd04a41184892e319601}{}\label{classincremental_f_e_1_1_f_e_model_a7dd3d4c235f2fd04a41184892e319601}
Writes the solution vector to a file


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+\_\+name} & Name of the file to be written to (including extension) \\
\hline
\end{DoxyParams}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!zero\+\_\+ghosts@{zero\+\_\+ghosts}}
\index{zero\+\_\+ghosts@{zero\+\_\+ghosts}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{zero\+\_\+ghosts(\+Solution\+Vector\+Type \&vector)}{zero_ghosts(SolutionVectorType &vector)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ void {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::zero\+\_\+ghosts (
\begin{DoxyParamCaption}
\item[{Solution\+Vector\+Type \&}]{vector}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_a0eb2401c8fde4bea7ed93527ee0e5f8a}{}\label{classincremental_f_e_1_1_f_e_model_a0eb2401c8fde4bea7ed93527ee0e5f8a}
Zero the ghost values of {\ttfamily vector} 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em vector} & The vector for which the ghost values are to be zeroed \\
\hline
\end{DoxyParams}


\subsection{Member Data Documentation}
\index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!assembly\+\_\+helper@{assembly\+\_\+helper}}
\index{assembly\+\_\+helper@{assembly\+\_\+helper}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{assembly\+\_\+helper}{assembly_helper}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ dealii\+::\+Galerkin\+Tools\+::\+Assembly\+Helper$<$spacedim$>$ {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::assembly\+\_\+helper\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_a937ea806f50796c76a45f36e6ec3cd29}{}\label{classincremental_f_e_1_1_f_e_model_a937ea806f50796c76a45f36e6ec3cd29}
The {\bf Assembly\+Helper} object defining the problem to be solved \index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!connections@{connections}}
\index{connections@{connections}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{connections}{connections}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ std\+::vector$<$boost\+::signals2\+::connection$>$ {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::connections\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_acf28a249a6d3800401624fc8bc8f3baf}{}\label{classincremental_f_e_1_1_f_e_model_acf28a249a6d3800401624fc8bc8f3baf}
A list of connections set up by \hyperlink{classincremental_f_e_1_1_f_e_model}{F\+E\+Model}. This allows for disconnection when the \hyperlink{classincremental_f_e_1_1_f_e_model}{F\+E\+Model} object is destructed \index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!constraints@{constraints}}
\index{constraints@{constraints}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{constraints}{constraints}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ const dealii\+::\+Smart\+Pointer$<$const {\bf Constraints}$<$spacedim$>$ $>$ {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::constraints\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_a33a622c3c53ea4bee3bdefac06201c70}{}\label{classincremental_f_e_1_1_f_e_model_a33a622c3c53ea4bee3bdefac06201c70}
The \hyperlink{classincremental_f_e_1_1_constraints}{Constraints} object comprising all the constraints to be applied \index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!dirichlet\+\_\+constraints@{dirichlet\+\_\+constraints}}
\index{dirichlet\+\_\+constraints@{dirichlet\+\_\+constraints}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{dirichlet\+\_\+constraints}{dirichlet_constraints}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ dealii\+::\+Affine\+Constraints$<$double$>$ {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::dirichlet\+\_\+constraints\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_a4ea39622157334a3d985c418a3b9ca34}{}\label{classincremental_f_e_1_1_f_e_model_a4ea39622157334a3d985c418a3b9ca34}
Matrix with Dirichlet type constraints (used internally during the solution process) \index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!dof\+\_\+renumbering@{dof\+\_\+renumbering}}
\index{dof\+\_\+renumbering@{dof\+\_\+renumbering}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{dof\+\_\+renumbering}{dof_renumbering}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ dealii\+::\+Galerkin\+Tools\+::\+Do\+F\+Renumbering\+Offset {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::dof\+\_\+renumbering\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_ae3bd54f0440c5dcaf08066efd786c341}{}\label{classincremental_f_e_1_1_f_e_model_ae3bd54f0440c5dcaf08066efd786c341}
Object defining dof renumbering scheme of assembly helper (only relevant in parallel) \index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!dp\+\_\+domain@{dp\+\_\+domain}}
\index{dp\+\_\+domain@{dp\+\_\+domain}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{dp\+\_\+domain}{dp_domain}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ std\+::vector$<$dealii\+::\+Smart\+Pointer$<$const dealii\+::\+Data\+Postprocessor$<$spacedim$>$ $>$ $>$ {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::dp\+\_\+domain\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_aff2f85b08282289389284138ca708eca}{}\label{classincremental_f_e_1_1_f_e_model_aff2f85b08282289389284138ca708eca}
{\bf Data\+Postprocessor} objects for domain cells. This allows for user-\/defined post-\/processing. \index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!dp\+\_\+interface@{dp\+\_\+interface}}
\index{dp\+\_\+interface@{dp\+\_\+interface}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{dp\+\_\+interface}{dp_interface}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ std\+::vector$<$dealii\+::\+Smart\+Pointer$<$const dealii\+::\+Data\+Postprocessor$<$spacedim$>$ $>$ $>$ {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::dp\+\_\+interface\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_adeb548ba39fe59036312bb8ba1d8cbf9}{}\label{classincremental_f_e_1_1_f_e_model_adeb548ba39fe59036312bb8ba1d8cbf9}
{\bf Data\+Postprocessor} objects for interface cells. This allows for user-\/defined post-\/processing. \index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!global\+\_\+data@{global\+\_\+data}}
\index{global\+\_\+data@{global\+\_\+data}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{global\+\_\+data}{global_data}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ const dealii\+::\+Smart\+Pointer$<${\bf Global\+Data\+Incremental\+FE}$<$spacedim$>$ $>$ {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::global\+\_\+data\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_aa6f80778241b26906af1f571517102dd}{}\label{classincremental_f_e_1_1_f_e_model_aa6f80778241b26906af1f571517102dd}
The \hyperlink{classincremental_f_e_1_1_global_data_incremental_f_e}{Global\+Data\+Incremental\+FE} object, which is used to exchange global information about the finite element model, the solution process, etc. In particular, this object contains the time step information, which may be needed within the {\bf Total\+Potential} to define the space-\/time discrete formulation. \index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!hanging\+\_\+node\+\_\+constraints@{hanging\+\_\+node\+\_\+constraints}}
\index{hanging\+\_\+node\+\_\+constraints@{hanging\+\_\+node\+\_\+constraints}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{hanging\+\_\+node\+\_\+constraints}{hanging_node_constraints}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ dealii\+::\+Affine\+Constraints$<$double$>$ {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::hanging\+\_\+node\+\_\+constraints\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_af333d1d12e78c27c74b033a85d075d38}{}\label{classincremental_f_e_1_1_f_e_model_af333d1d12e78c27c74b033a85d075d38}
Matrix with hanging node constraints (used internally during the solution process) \index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!make\+\_\+hanging\+\_\+node\+\_\+constraints@{make\+\_\+hanging\+\_\+node\+\_\+constraints}}
\index{make\+\_\+hanging\+\_\+node\+\_\+constraints@{make\+\_\+hanging\+\_\+node\+\_\+constraints}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{make\+\_\+hanging\+\_\+node\+\_\+constraints}{make_hanging_node_constraints}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ const bool {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::make\+\_\+hanging\+\_\+node\+\_\+constraints\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_a65b5910cfba2feb26933ad451ceff628}{}\label{classincremental_f_e_1_1_f_e_model_a65b5910cfba2feb26933ad451ceff628}
determines whether hanging node constraints are taken into account or ignored \index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!potential\+\_\+value@{potential\+\_\+value}}
\index{potential\+\_\+value@{potential\+\_\+value}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{potential\+\_\+value}{potential_value}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ double {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::potential\+\_\+value = 0.\+0\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_a04ea9240ef0084b44471a40f0d64ac54}{}\label{classincremental_f_e_1_1_f_e_model_a04ea9240ef0084b44471a40f0d64ac54}
Current value of the total potential (used internally during the solution process) \index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!rhs@{rhs}}
\index{rhs@{rhs}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{rhs}{rhs}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ R\+H\+S\+Vector\+Type {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::rhs\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_aba8e9e925aa72d2dd0f86c451b2cf3d6}{}\label{classincremental_f_e_1_1_f_e_model_aba8e9e925aa72d2dd0f86c451b2cf3d6}
Right hand side vector (used internally during the solution process) \index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!rhs\+\_\+scaling\+\_\+vector@{rhs\+\_\+scaling\+\_\+vector}}
\index{rhs\+\_\+scaling\+\_\+vector@{rhs\+\_\+scaling\+\_\+vector}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{rhs\+\_\+scaling\+\_\+vector}{rhs_scaling_vector}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ R\+H\+S\+Vector\+Type {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::rhs\+\_\+scaling\+\_\+vector\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_a26ffe7f5ecf94f3bdbe27f4ea3e577dc}{}\label{classincremental_f_e_1_1_f_e_model_a26ffe7f5ecf94f3bdbe27f4ea3e577dc}
Vector used to scale elements of \hyperlink{classincremental_f_e_1_1_f_e_model_aba8e9e925aa72d2dd0f86c451b2cf3d6}{F\+E\+Model\+::rhs} before computing 2-\/norm thereof (each element of \hyperlink{classincremental_f_e_1_1_f_e_model_aba8e9e925aa72d2dd0f86c451b2cf3d6}{F\+E\+Model\+::rhs} is scaled by the reciprocal value of the corresponding element of \hyperlink{classincremental_f_e_1_1_f_e_model_a26ffe7f5ecf94f3bdbe27f4ea3e577dc}{F\+E\+Model\+::rhs\+\_\+scaling\+\_\+vector}). This scaling is used to avoid ill-\/conditioning problems. The \hyperlink{classincremental_f_e_1_1_f_e_model_a26ffe7f5ecf94f3bdbe27f4ea3e577dc}{F\+E\+Model\+::rhs\+\_\+scaling\+\_\+vector} is computed in the beginning of each time step based on the initial system matrix and then kept constant throughout the time step. Each element in \hyperlink{classincremental_f_e_1_1_f_e_model_a26ffe7f5ecf94f3bdbe27f4ea3e577dc}{F\+E\+Model\+::rhs\+\_\+scaling\+\_\+vector} is equal to the maximum norm of the corresponding row in the initial system matrix. \index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!solution@{solution}}
\index{solution@{solution}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{solution}{solution}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ Solution\+Vector\+Type {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::solution\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_a02134975db38fcf4f7ce698d605baa30}{}\label{classincremental_f_e_1_1_f_e_model_a02134975db38fcf4f7ce698d605baa30}
Solution vector with the current solution \index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!solver\+\_\+wrapper@{solver\+\_\+wrapper}}
\index{solver\+\_\+wrapper@{solver\+\_\+wrapper}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{solver\+\_\+wrapper}{solver_wrapper}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ const dealii\+::\+Smart\+Pointer$<$const dealii\+::\+Galerkin\+Tools\+::\+Solver\+Wrapper$<$Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type, dealii\+::\+Galerkin\+Tools\+::\+Two\+Block\+Sparsity\+Pattern$>$ $>$ {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::solver\+\_\+wrapper\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_a609de66ca9623d737bf3a45a37bb7690}{}\label{classincremental_f_e_1_1_f_e_model_a609de66ca9623d737bf3a45a37bb7690}
The {\bf Solver\+Wrapper} provides the functionality to solve the linear systems within each Newton-\/\+Raphson iteration \index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!sparsity\+\_\+pattern@{sparsity\+\_\+pattern}}
\index{sparsity\+\_\+pattern@{sparsity\+\_\+pattern}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{sparsity\+\_\+pattern}{sparsity_pattern}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ dealii\+::\+Galerkin\+Tools\+::\+Two\+Block\+Sparsity\+Pattern {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::sparsity\+\_\+pattern\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_ac5c04f79916df3cc38ac64209051eecd}{}\label{classincremental_f_e_1_1_f_e_model_ac5c04f79916df3cc38ac64209051eecd}
The sparsity pattern of the system matrix \hyperlink{classincremental_f_e_1_1_f_e_model_abc07b7d142d78230bcd55274f35514b3}{F\+E\+Model\+::system\+\_\+matrix} (used internally during the solution process) \index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!system\+\_\+matrix@{system\+\_\+matrix}}
\index{system\+\_\+matrix@{system\+\_\+matrix}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{system\+\_\+matrix}{system_matrix}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ Matrix\+Type {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::system\+\_\+matrix\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_abc07b7d142d78230bcd55274f35514b3}{}\label{classincremental_f_e_1_1_f_e_model_abc07b7d142d78230bcd55274f35514b3}
System matrix (used internally during the solution process) \index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!times\+\_\+and\+\_\+names\+\_\+domain@{times\+\_\+and\+\_\+names\+\_\+domain}}
\index{times\+\_\+and\+\_\+names\+\_\+domain@{times\+\_\+and\+\_\+names\+\_\+domain}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{times\+\_\+and\+\_\+names\+\_\+domain}{times_and_names_domain}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ std\+::vector$<$ std\+::pair$<$double, std\+::string$>$ $>$ {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::times\+\_\+and\+\_\+names\+\_\+domain\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_a9a6cc0723bdeb129e330179ed4a87670}{}\label{classincremental_f_e_1_1_f_e_model_a9a6cc0723bdeb129e330179ed4a87670}
Pairs of time and filename of outputs written to files (for domain output). This is used in order to generate files gathering all the output files of the individual time steps into one file, which can be opened for post-\/processing. \index{incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}!times\+\_\+and\+\_\+names\+\_\+interface@{times\+\_\+and\+\_\+names\+\_\+interface}}
\index{times\+\_\+and\+\_\+names\+\_\+interface@{times\+\_\+and\+\_\+names\+\_\+interface}!incremental\+F\+E\+::\+F\+E\+Model@{incremental\+F\+E\+::\+F\+E\+Model}}
\subsubsection[{\texorpdfstring{times\+\_\+and\+\_\+names\+\_\+interface}{times_and_names_interface}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim, class Solution\+Vector\+Type, class R\+H\+S\+Vector\+Type, class Matrix\+Type$>$ std\+::vector$<$ std\+::pair$<$double, std\+::string$>$ $>$ {\bf incremental\+F\+E\+::\+F\+E\+Model}$<$ spacedim, Solution\+Vector\+Type, R\+H\+S\+Vector\+Type, Matrix\+Type $>$\+::times\+\_\+and\+\_\+names\+\_\+interface\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classincremental_f_e_1_1_f_e_model_aaa0e0ef1be909224dfe6f28484b9d754}{}\label{classincremental_f_e_1_1_f_e_model_aaa0e0ef1be909224dfe6f28484b9d754}
Pairs of time and filename of outputs written to files (for interface output). This is used in order to generate files gathering all the output files of the individual time steps into one file, which can be opened for post-\/processing. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/sst/code/\+Incremental\+F\+E/\+Incremental\+F\+E/include/incremental\+\_\+fe/\hyperlink{fe__model_8h}{fe\+\_\+model.\+h}\end{DoxyCompactItemize}
